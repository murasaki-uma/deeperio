
script(id="computeParticlePosition" type="x-shader/x-fragment").
    // 現在の位置情報を決定する
    #define delta ( 1.0 / 60.0 )
    void main() {
        vec2 uv = gl_FragCoord.xy / resolution.xy;
        vec4 tmpPos = texture2D( textureParticlePosition, uv );
        vec3 pos = tmpPos.xyz;
        vec4 tmpVel = texture2D( textureParticleVelocity, uv );
        // velが移動する方向(もう一つ下のcomputeShaderVelocityを参照)
        vec3 vel = tmpVel.xyz;

        // 移動する方向に速度を掛け合わせた数値を現在地に加える。
        pos += vel * delta;
        gl_FragColor = vec4( pos, 1.0 );
    }

script(id="computeParticleVelocity" type="x-shader/x-fragment").

    #include <common>

    void main() {
        vec2 uv = gl_FragCoord.xy / resolution.xy;
        float idParticle = uv.y * resolution.x + uv.x;
        vec4 tmpVel = texture2D( textureParticleVelocity, uv );
        vec3 vel = tmpVel.xyz;

        gl_FragColor = vec4( vel.xyz, 1.0 );
    }

script(type="x-shader/x-vertex" id="particleVertexShader").


    #include <common>
    uniform sampler2D textureParticlePosition;
    uniform float cameraConstant;
    uniform float density;
    varying vec4 vColor;
    varying vec2 vUv;
    uniform float radius;
    void main() {
        vec4 posTemp = texture2D( textureParticlePosition, uv );
        vec3 pos = posTemp.xyz;
    vColor = vec4( 1.0, 0.7, 1.0, 1.0 );

        // ポイントのサイズを決定
        vec4 mvPosition = modelViewMatrix * vec4( pos, 1.0 );
    gl_PointSize = 0.5 * cameraConstant / ( - mvPosition.z );

        // uv情報の引き渡し
    vUv = uv;

        // 変換して格納
    gl_Position = projectionMatrix * mvPosition;
    }

script(type="x-shader/x-fragment" id="particleFragmentShader").
    varying vec4 vColor;
    void main() {

        float f = length( gl_PointCoord - vec2( 0.5, 0.5 ) );
        if ( f > 0.1 ) {
            discard;
        }
        gl_FragColor = vColor;
    }

